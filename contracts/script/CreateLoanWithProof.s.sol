// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Script, console2} from "forge-std/Script.sol";
import {LoanEngine} from "../src/LoanEngine.sol";
import {CreditPolicy} from "../src/CreditPolicy.sol";
import {ICreditPolicy} from "../src/interfaces/ICreditPolicy.sol";
import {TranchePool} from "../src/TranchePool.sol";
import {IVerifier} from "../src/interfaces/IVerifier.sol";

/**
 * @title CreateLoanWithProof
 * @notice Creates a loan using a ZK proof generated by the TypeScript script
 *
 * This script expects the proof data to be passed via environment variables
 * or read from a file generated by the proof generator.
 *
 * Usage:
 * 1. First run the TypeScript proof generator to create proof.json
 * 2. Then run this script:
 *
 * forge script script/CreateLoanWithProof.s.sol:CreateLoanWithProof \
 *   --zk-compile --rpc-url http://127.0.0.1:8546 \
 *   --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 \
 *   --broadcast -vvv
 */
contract CreateLoanWithProof is Script {
    function run() external {
        // Get deployed addresses from environment
        address loanEngineAddr = vm.envAddress("LOAN_ENGINE_ADDRESS");
        address creditPolicyAddr = vm.envAddress("CREDIT_POLICY_ADDRESS");
        address tranchePoolAddr = vm.envAddress("TRANCHE_POOL_ADDRESS");

        uint256 deployerPrivateKey = vm.envOr(
            "PRIVATE_KEY",
            uint256(
                0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
            )
        );

        console2.log("=== Create Loan with ZK Proof ===");
        console2.log("LoanEngine:", loanEngineAddr);
        console2.log("CreditPolicy:", creditPolicyAddr);
        console2.log("TranchePool:", tranchePoolAddr);

        LoanEngine loanEngine = LoanEngine(loanEngineAddr);
        CreditPolicy creditPolicy = CreditPolicy(creditPolicyAddr);
        TranchePool tranchePool = TranchePool(tranchePoolAddr);

        vm.startBroadcast(deployerPrivateKey);

        // Step 1: Create and freeze a policy
        console2.log("");
        console2.log("Step 1: Creating and configuring credit policy...");

        uint256 policyVersion = 1;
        creditPolicy.createPolicy(policyVersion);

        // Set eligibility criteria
        creditPolicy.updateEligibility(
            policyVersion,
            ICreditPolicy.EligibilityCriteria({
                minAnnualRevenue: 1_000_000,
                minEBITDA: 100_000,
                minTangibleNetWorth: 250_000,
                minBusinessAgeDays: 730,
                maxDefaultsLast36Months: 0,
                bankruptcyExcluded: true
            })
        );

        // Set financial ratios
        creditPolicy.updateRatios(
            policyVersion,
            ICreditPolicy.FinancialRatios({
                maxTotalDebtToEBITDA: 40_000,
                minInterestCoverageRatio: 15_000,
                minCurrentRatio: 12_000,
                minEBITDAMarginBps: 1000
            })
        );

        // Set concentration limits
        creditPolicy.updateConcentration(
            policyVersion,
            ICreditPolicy.ConcentrationLimits({
                maxSingleBorrowerBps: 1000,
                maxIndustryConcentrationBps: 2500
            })
        );

        // Set attestation requirements
        creditPolicy.updateAttestation(
            policyVersion,
            ICreditPolicy.AttestationRequirements({
                maxAttestationAgeDays: 90,
                reAttestationFrequencyDays: 365,
                requiresCPAAttestation: false
            })
        );

        // Set covenants
        creditPolicy.updateCovenants(
            policyVersion,
            ICreditPolicy.MaintenanceCovenants({
                maxLeverageRatio: 50_000,
                minCoverageRatio: 10_000,
                minLiquidityAmount: 100_000,
                allowsDividends: true,
                reportingFrequencyDays: 30
            })
        );

        // Set a loan tier
        creditPolicy.setLoanTier(
            policyVersion,
            1,
            ICreditPolicy.LoanTier({
                name: "Standard",
                minRevenue: 1_000_000,
                maxRevenue: 10_000_000,
                minEBITDA: 100_000,
                maxDebtToEBITDA: 40_000,
                maxLoanToEBITDA: 1e18,
                interestRateBps: 1200,
                originationFeeBps: 100,
                termDays: 365,
                active: true
            })
        );

        // Freeze the policy
        creditPolicy.freezePolicy(policyVersion);
        console2.log("  Policy created and frozen");

        // Step 2: Configure TranchePool state
        console2.log("");
        console2.log("Step 2: Configuring TranchePool...");

        // Check current state and advance if needed
        TranchePool.PoolState currentState = tranchePool.getPoolState();
        console2.log("  Current pool state:", uint256(currentState));

        if (currentState == TranchePool.PoolState.OPEN) {
            // Need to transition to COMMITED for loan origination
            console2.log(
                "  Pool in OPEN state - transition to COMMITED for loan origination"
            );
        }

        vm.stopBroadcast();

        console2.log("");
        console2.log("=== Policy Setup Complete ===");
        console2.log("");
        console2.log("Next steps:");
        console2.log(
            "1. Generate ZK proof using: cd ../zk-scripts && npm run generate-proof"
        );
        console2.log(
            "2. Run CreateLoanWithZkProof script with the generated proof"
        );
    }
}

/**
 * @title CreateLoanWithZkProof
 * @notice Actually creates the loan using proof data from FFI
 */
contract CreateLoanWithZkProof is Script {
    function run() external {
        address loanEngineAddr = vm.envAddress("LOAN_ENGINE_ADDRESS");
        uint256 deployerPrivateKey = vm.envOr(
            "PRIVATE_KEY",
            uint256(
                0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
            )
        );

        LoanEngine loanEngine = LoanEngine(loanEngineAddr);

        console2.log("=== Creating Loan with ZK Proof ===");
        console2.log("LoanEngine:", loanEngineAddr);

        // Run FFI to generate proof
        console2.log("");
        console2.log("Generating ZK proof via FFI...");

        string[] memory inputs = new string[](3);
        inputs[0] = "npx";
        inputs[1] = "tsx";
        inputs[2] = "../zk-scripts/generate_proof_ffi.ts";

        bytes memory result = vm.ffi(inputs);

        // Decode the proof data
        (
            bytes memory proofData,
            bytes32[] memory publicInputs,
            bytes32 policyHash,
            bytes32 loanHash,
            bytes32 nullifierHash,
            bytes32 borrowerCommitment,
            bytes32 underwriterKeyX,
            bytes32 underwriterKeyY,
            bytes32 industryHash,
            uint256 proofTimestamp
        ) = abi.decode(
                result,
                (
                    bytes,
                    bytes32[],
                    bytes32,
                    bytes32,
                    bytes32,
                    bytes32,
                    bytes32,
                    bytes32,
                    bytes32,
                    uint256
                )
            );

        console2.log("  Proof generated successfully");
        console2.log("  Proof size:", proofData.length);
        console2.log("  Public inputs:", publicInputs.length);

        // Verify the proof works
        address verifierAddr = vm.envAddress("VERIFIER_ADDRESS");
        IVerifier verifier = IVerifier(verifierAddr);

        bool isValid = verifier.verify(proofData, publicInputs);
        require(isValid, "Proof verification failed!");
        console2.log("  Proof verified on-chain!");

        vm.startBroadcast(deployerPrivateKey);

        // Create loan params
        LoanEngine.CreateLoanParams memory params = LoanEngine
            .CreateLoanParams({
                borrowerCommitment: borrowerCommitment,
                nullifierHash: nullifierHash,
                policyVersion: 1,
                tierId: 1,
                principalIssued: 500_000 * 1e6, // 500k USDC
                aprBps: 1200, // 12%
                originationFeeBps: 100, // 1%
                termDays: 365,
                industry: industryHash,
                underwriterKeyX: underwriterKeyX,
                underwriterKeyY: underwriterKeyY,
                proofTimestamp: proofTimestamp
            });

        // Create the loan
        console2.log("");
        console2.log("Creating loan...");
        loanEngine.createLoan(params, proofData, publicInputs);

        uint256 loanId = loanEngine.getNextLoanId() - 1;
        console2.log("  Loan created with ID:", loanId);

        vm.stopBroadcast();

        console2.log("");
        console2.log("=== SUCCESS ===");
        console2.log("Loan created and verified with ZK proof!");
    }
}
