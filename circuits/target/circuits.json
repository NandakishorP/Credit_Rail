{"noir_version":"1.0.0-beta.16+2d46fca7203545cbbfb31a0d0328de6c10a8db95","hash":"3147288565121682205","abi":{"parameters":[{"name":"policy_version_hash","type":{"kind":"field"},"visibility":"public"},{"name":"loan_hash","type":{"kind":"field"},"visibility":"public"},{"name":"nullifierHash","type":{"kind":"field"},"visibility":"public"},{"name":"borrower_commitment","type":{"kind":"field"},"visibility":"private"},{"name":"underwriter_public_key_x","type":{"kind":"field"},"visibility":"private"},{"name":"underwriter_public_key_y","type":{"kind":"field"},"visibility":"private"},{"name":"tier_id","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"loan_principal","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"loan_apr_bps","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"loan_origination_fee_bps","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"loan_term_days","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"industry_hash","type":{"kind":"field"},"visibility":"private"},{"name":"current_timestamp","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"loanId","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"underwriter_signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"borrower_secret","type":{"kind":"field"},"visibility":"private"},{"name":"borrower_annual_revenue","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"borrower_ebitda","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"borrower_tangible_net_worth","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"borrower_business_age_days","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"borrower_defaults_last_36_months","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"borrower_has_bankruptcy","type":{"kind":"boolean"},"visibility":"private"},{"name":"borrower_debt_to_ebitda","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"borrower_interest_coverage","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"borrower_current_ratio","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"borrower_ebitda_margin_bps","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"attestation_timestamp","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"policy_min_annual_revenue","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"policy_min_ebitda","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"policy_min_tangible_net_worth","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"policy_min_business_age_days","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"policy_max_defaults_36_months","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"policy_bankruptcy_excluded","type":{"kind":"boolean"},"visibility":"private"},{"name":"policy_max_debt_to_ebitda","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"policy_min_interest_coverage","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"policy_min_current_ratio","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"policy_min_ebitda_margin_bps","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"policy_max_attestation_age_days","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"tier_min_revenue","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"tier_max_revenue","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"tier_min_ebitda","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"tier_max_debt_to_ebitda","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"tier_max_loan_to_ebitda","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"tier_interest_rate_bps","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"tier_origination_fee_bps","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"tier_term_days","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"tier_active","type":{"kind":"boolean"},"visibility":"private"}],"return_type":null,"error_types":{"146392328554997772":{"error_kind":"string","string":"Loan principal must be non-zero"},"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"491929095056552706":{"error_kind":"string","string":"Timestamp overflow"},"734184470535087102":{"error_kind":"string","string":"EBITDA below minimum"},"930147594447801428":{"error_kind":"string","string":"APR does not match tier rate"},"1115600012306409724":{"error_kind":"string","string":"Borrower EBITDA must be non-zero"},"1484033922454555398":{"error_kind":"string","string":"Revenue above tier maximum"},"1619663967908890922":{"error_kind":"string","string":"Loan principal too large"},"1838530235959724618":{"error_kind":"string","string":"Term does not match tier"},"1996347121589534211":{"error_kind":"string","string":"Business age below minimum"},"1996647130518093403":{"error_kind":"string","string":"Loan hash mismatch"},"2079713649108529883":{"error_kind":"string","string":"Tier loan-to-EBITDA ratio too large"},"2512091849089393042":{"error_kind":"string","string":"Revenue below tier minimum"},"2946657144099864747":{"error_kind":"string","string":"Too many defaults in last 36 months"},"4689194422187179712":{"error_kind":"string","string":"Debt-to-EBITDA ratio exceeds maximum"},"4743545721632785176":{"error_kind":"string","string":"Nullifier mismatch"},"4812443725483104649":{"error_kind":"string","string":"Tangible net worth below minimum"},"5109601609985968310":{"error_kind":"string","string":"Annual revenue below minimum"},"5726572372160767216":{"error_kind":"string","string":"APR exceeds 100%"},"5972147825262328827":{"error_kind":"string","string":"Loan tier is not active"},"7037611653121423555":{"error_kind":"string","string":"Invalid underwriter signature"},"8658286639427320149":{"error_kind":"string","string":"Origination fee does not match tier"},"8874376631921438173":{"error_kind":"string","string":"Bankruptcy excludes borrower"},"9275322503366057033":{"error_kind":"string","string":"Loan-to-EBITDA exceeds tier maximum"},"9302170638635664401":{"error_kind":"string","string":"Attestation expired"},"10091540362309321312":{"error_kind":"string","string":"Policy hash mismatch"},"10560849604424664400":{"error_kind":"string","string":"Borrower commitment mismatch"},"10673812805185337740":{"error_kind":"string","string":"Policy age too large"},"11012375049564024093":{"error_kind":"string","string":"Loan term must be non-zero"},"11191803990096845963":{"error_kind":"string","string":"EBITDA too large"},"12367978774114052772":{"error_kind":"string","string":"Loan term exceeds 10 years"},"13221832406298074397":{"error_kind":"string","string":"Debt-to-EBITDA exceeds tier maximum"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15194875375746594723":{"error_kind":"string","string":"Current ratio below minimum"},"15312520319994623833":{"error_kind":"string","string":"EBITDA margin below minimum"},"15467612597352701580":{"error_kind":"string","string":"EBITDA below tier minimum"},"15528649736397755158":{"error_kind":"string","string":"Attestation time in future"},"15835548349546956319":{"error_kind":"string","string":"Field failed to decompose into specified 32 limbs"},"18096564420567236403":{"error_kind":"string","string":"Interest coverage ratio below minimum"}}},"bytecode":"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","debug_symbols":"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","file_map":{"14":{"source":"// docs:start:ecdsa_secp256k1\n/// Verifies a ECDSA signature over the secp256k1 curve.\n/// - inputs:\n///     - x coordinate of public key as 32 bytes\n///     - y coordinate of public key as 32 bytes\n///     - the signature, as a 64 bytes array\n///       The signature internally will be represented as `(r, s)`,\n///       where `r` and `s` are fixed-sized big endian scalar values.\n///       As the `secp256k1` has a 256-bit modulus, we have a 64 byte signature\n///       while `r` and `s` will both be 32 bytes.\n///       We expect `s` to be normalized. This means given the curve's order,\n///       `s` should be less than or equal to `order / 2`.\n///       This is done to prevent malleability.\n///       For more context regarding malleability you can reference BIP 0062.\n///     - the hash of the message, as a vector of bytes\n/// - output: false for failure and true for success\npub fn verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n) -> bool\n// docs:end:ecdsa_secp256k1\n{\n    _verify_signature(public_key_x, public_key_y, signature, message_hash, true)\n}\n\n#[foreign(ecdsa_secp256k1)]\nfn _verify_signature(\n    public_key_x: [u8; 32],\n    public_key_y: [u8; 32],\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n    predicate: bool,\n) -> bool {}\n","path":"std/ecdsa_secp256k1.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"use poseidon::poseidon2;\n\n/// Credit Policy Compliance Circuit\n///\n/// Proves that a loan request adheres to a frozen credit policy version.\n/// This circuit verifies:\n/// 1. Borrower meets eligibility criteria\n/// 2. Borrower's financial ratios pass underwriting thresholds\n/// 3. Loan terms match the specified tier\n/// 4. Industry is not excluded\n/// 5. Borrower commitment binds private data to the proof\n/// 6. Underwriter signature validates the borrower data\n///\n/// Public Inputs (visible on-chain):\n/// - policy_version_hash: Hash of the frozen policy (links proof to immutable policy)\n/// - borrower_commitment: Hash(borrower_secret, borrower_data) - privacy-preserving borrower binding\n/// - underwriter_public_key_x: X coordinate of underwriter's public key\n/// - underwriter_public_key_y: Y coordinate of underwriter's public key\n/// - tier_id: The loan tier being used\n/// - loan_principal: Requested principal amount\n/// - loan_apr_bps: Annual interest rate in basis points\n/// - loan_origination_fee_bps: Origination fee in basis points\n/// - loan_term_days: Loan term in days\n/// - industry_hash: Hash of borrower's industry code\n///\n/// Private Inputs (hidden in proof):\n/// - underwriter_signature: Schnorr signature over borrower data\n/// - borrower_secret: Secret known only to borrower (for commitment)\n/// - eligibility criteria values (borrower's actual metrics)\n/// - financial ratio values (borrower's actual ratios)\n/// - policy tier constraints (from the frozen policy)\n/// - policy eligibility constraints (from the frozen policy)\n/// - policy ratio constraints (from the frozen policy)\n\n//==============================================================\n//                       MAIN CIRCUIT\n//==============================================================\n\nfn main(\n    // === Public Inputs (exposed to verifier) ===\n    policy_version_hash: pub Field, // Hash of policy version (commitment to frozen policy)\n    loan_hash: pub Field,\n    nullifierHash: pub Field,\n    borrower_commitment: Field, // Hash(secret || borrower_data)\n    underwriter_public_key_x: Field, // Underwriter PK X\n    underwriter_public_key_y: Field, // Underwriter PK Y\n    tier_id: u8, // Tier ID from policy\n    loan_principal: u64, // Requested loan principal\n    loan_apr_bps: u64, // Interest rate in basis points\n    loan_origination_fee_bps: u64, // Origination fee in basis points\n    loan_term_days: u64, // Term in days\n    industry_hash: Field, // Hash of industry code\n    current_timestamp: u64, // Current block time (approx)\n    loanId: u64,\n    // === Private Inputs (hidden from verifier) ===\n    // Underwriter signature\n    underwriter_signature: [u8; 64],\n    // Borrower secret for commitment\n    borrower_secret: Field,\n    // Borrower eligibility data (private - actual values)\n    borrower_annual_revenue: u64,\n    borrower_ebitda: u64,\n    borrower_tangible_net_worth: u64,\n    borrower_business_age_days: u64,\n    borrower_defaults_last_36_months: u64,\n    borrower_has_bankruptcy: bool,\n    // Borrower financial ratios (private - actual values, scaled by 1e4 for precision)\n    borrower_debt_to_ebitda: u64, // e.g., 3.5x = 35000\n    borrower_interest_coverage: u64, // e.g., 2.0x = 20000\n    borrower_current_ratio: u64, // e.g., 1.5x = 15000\n    borrower_ebitda_margin_bps: u64, // e.g., 15% = 1500 bps\n    // Attestation Data\n    attestation_timestamp: u64, // When the underwriter signed/verified checks\n    // Policy eligibility constraints (private - from frozen policy)\n    policy_min_annual_revenue: u64,\n    policy_min_ebitda: u64,\n    policy_min_tangible_net_worth: u64,\n    policy_min_business_age_days: u64,\n    policy_max_defaults_36_months: u64,\n    policy_bankruptcy_excluded: bool,\n    // Policy ratio constraints (private - from frozen policy)\n    policy_max_debt_to_ebitda: u64,\n    policy_min_interest_coverage: u64,\n    policy_min_current_ratio: u64,\n    policy_min_ebitda_margin_bps: u64,\n    policy_max_attestation_age_days: u64, // Added\n    // Policy Tier constraints (private - from frozen policy)\n    tier_min_revenue: u64,\n    tier_max_revenue: u64,\n    tier_min_ebitda: u64,\n    tier_max_debt_to_ebitda: u64,\n    tier_max_loan_to_ebitda: u64,\n    tier_interest_rate_bps: u64,\n    tier_origination_fee_bps: u64,\n    tier_term_days: u64,\n    tier_active: bool,\n) {\n    let computed_loan_hash = compute_loan_hash(\n        borrower_commitment,\n        underwriter_public_key_x,\n        underwriter_public_key_y,\n        tier_id,\n        loan_principal,\n        loan_apr_bps,\n        loan_origination_fee_bps,\n        loan_term_days,\n        industry_hash,\n        current_timestamp,\n        loanId,\n    );\n\n    assert(computed_loan_hash == loan_hash, \"Loan hash mismatch\");\n    //==============================================================\n    //             1. VERIFY BORROWER COMMITMENT\n    //==============================================================\n    //==============================================================\n    //             1. VERIFY BORROWER COMMITMENT\n    //==============================================================\n    verify_borrower_commitment(\n        borrower_commitment,\n        borrower_secret,\n        borrower_annual_revenue,\n        borrower_ebitda,\n        borrower_tangible_net_worth,\n        borrower_business_age_days,\n    );\n\n    let computed_nullifier_hash = poseidon2::Poseidon2::hash(\n        [loanId as Field, borrower_secret, loan_principal as Field, attestation_timestamp as Field],\n        4,\n    );\n    assert(computed_nullifier_hash == nullifierHash, \"Nullifier mismatch\");\n\n    //==============================================================\n    //             1b. VERIFY ATTESATION AGE\n    //==============================================================\n    verify_attestation_age(\n        current_timestamp,\n        attestation_timestamp,\n        policy_max_attestation_age_days,\n    );\n\n    //==============================================================\n    //             1c. VERIFY UNDERWRITER SIGNATURE\n    //==============================================================\n    // The underwriter signs the raw data (without the borrower's secret).\n    // This ensures that the data being proven (revenue, ebitda, etc.) was\n    // explicitly authorized by the underwriter's private key.\n\n    // 1. Hash the data (must match what was signed off-chain)\n    // Note: We cast to Field for Poseidon. The signer must sign this exact sequence.\n    let data_to_sign_hash = poseidon2::Poseidon2::hash(\n        [\n            borrower_annual_revenue as Field,\n            borrower_ebitda as Field,\n            borrower_tangible_net_worth as Field,\n            borrower_business_age_days as Field,\n            borrower_defaults_last_36_months as Field,\n            borrower_has_bankruptcy as Field,\n            borrower_debt_to_ebitda as Field,\n            borrower_interest_coverage as Field,\n            borrower_current_ratio as Field,\n            borrower_ebitda_margin_bps as Field,\n            industry_hash, // Bind industry to the signature\n            attestation_timestamp as Field, // Bind timestamp to signature (Prevent Replay)\n        ],\n        12,\n    );\n\n    // 2. Convert hash to bytes for Schnorr verification (standard practice)\n    // Field elements are 32 bytes (254 bits).\n    let message_bytes: [u8; 32] = data_to_sign_hash.to_be_bytes();\n\n    // 3. Verify Signature (ECDSA Secp256k1)\n    // Convert Field public keys to bytes for ECDSA\n    let pk_x_bytes = underwriter_public_key_x.to_be_bytes();\n    let pk_y_bytes = underwriter_public_key_y.to_be_bytes();\n\n    let is_valid_sig = std::ecdsa_secp256k1::verify_signature(\n        pk_x_bytes,\n        pk_y_bytes,\n        underwriter_signature,\n        message_bytes,\n    );\n    assert(is_valid_sig, \"Invalid underwriter signature\");\n\n    //==============================================================\n    //             2. VERIFY POLICY VERSION HASH\n    //==============================================================\n    // We must hash ALL policy constraints to ensure the proof is bound\n    // to the specific frozen policy version.\n    let computed_policy_hash = compute_policy_hash(\n        policy_min_annual_revenue,\n        policy_min_ebitda,\n        policy_min_tangible_net_worth,\n        policy_min_business_age_days,\n        policy_max_defaults_36_months,\n        policy_bankruptcy_excluded,\n        policy_max_debt_to_ebitda,\n        policy_min_interest_coverage,\n        policy_min_current_ratio,\n        policy_min_ebitda_margin_bps,\n        policy_max_attestation_age_days,\n        tier_id,\n        tier_min_revenue,\n        tier_max_revenue,\n        tier_min_ebitda,\n        tier_max_debt_to_ebitda,\n        tier_max_loan_to_ebitda,\n        tier_interest_rate_bps,\n        tier_origination_fee_bps,\n        tier_term_days,\n        tier_active,\n    );\n    assert(computed_policy_hash == policy_version_hash, \"Policy hash mismatch\");\n\n    //==============================================================\n    //             3. VERIFY POLICY COMPLIANCE\n    //==============================================================\n    validate_policy_compliance(\n        borrower_annual_revenue,\n        borrower_ebitda,\n        borrower_tangible_net_worth,\n        borrower_business_age_days,\n        borrower_defaults_last_36_months,\n        borrower_has_bankruptcy,\n        borrower_debt_to_ebitda,\n        borrower_interest_coverage,\n        borrower_current_ratio,\n        borrower_ebitda_margin_bps,\n        policy_min_annual_revenue,\n        policy_min_ebitda,\n        policy_min_tangible_net_worth,\n        policy_min_business_age_days,\n        policy_max_defaults_36_months,\n        policy_bankruptcy_excluded,\n        policy_max_debt_to_ebitda,\n        policy_min_interest_coverage,\n        policy_min_current_ratio,\n        policy_min_ebitda_margin_bps,\n        tier_min_revenue,\n        tier_max_revenue,\n        tier_min_ebitda,\n        tier_max_debt_to_ebitda,\n        tier_max_loan_to_ebitda,\n        tier_interest_rate_bps,\n        tier_origination_fee_bps,\n        tier_term_days,\n        tier_active,\n        loan_principal,\n        loan_apr_bps,\n        loan_origination_fee_bps,\n        loan_term_days,\n    );\n\n    // Industry exclusion is verified on-chain by LoanEngine check against\n    // the industry_hash public input and the policy's excluded list.\n}\n\nfn compute_loan_hash(\n    borrower_commitment: Field,\n    underwriter_public_key_x: Field,\n    underwriter_public_key_y: Field,\n    tier_id: u8,\n    loan_principal: u64,\n    loan_apr_bps: u64,\n    loan_origination_fee_bps: u64,\n    loan_term_days: u64,\n    industry_hash: Field,\n    current_timestamp: u64,\n    loanId: u64,\n) -> Field {\n    poseidon2::Poseidon2::hash(\n        [\n            borrower_commitment,\n            underwriter_public_key_x,\n            underwriter_public_key_y,\n            tier_id as Field,\n            loan_principal as Field,\n            loan_apr_bps as Field,\n            loan_origination_fee_bps as Field,\n            loan_term_days as Field,\n            industry_hash,\n            current_timestamp as Field,\n            loanId as Field,\n        ],\n        11,\n    )\n}\n\nfn verify_borrower_commitment(\n    borrower_commitment: Field,\n    borrower_secret: Field,\n    borrower_annual_revenue: u64,\n    borrower_ebitda: u64,\n    borrower_tangible_net_worth: u64,\n    borrower_business_age_days: u64,\n) {\n    let computed_commitment = poseidon2::Poseidon2::hash(\n        [\n            borrower_secret,\n            borrower_annual_revenue as Field,\n            borrower_ebitda as Field,\n            borrower_tangible_net_worth as Field,\n            borrower_business_age_days as Field,\n        ],\n        5,\n    );\n    assert(computed_commitment == borrower_commitment, \"Borrower commitment mismatch\");\n}\n\nfn verify_attestation_age(\n    current_timestamp: u64,\n    attestation_timestamp: u64,\n    policy_max_attestation_age_days: u64,\n) {\n    // Ensure the attestation is not expired\n    assert(current_timestamp >= attestation_timestamp, \"Attestation time in future\");\n\n    // Guard against overflow: Ensure policy max age is reasonable (e.g., < 27 years)\n    assert(policy_max_attestation_age_days < 10000, \"Policy age too large\");\n    let max_age_seconds = policy_max_attestation_age_days * 86400;\n\n    // Guard against u64 overflow in addition\n    // 0xffffffffffffffff = 18446744073709551615\n    assert(attestation_timestamp <= 18446744073709551615 - max_age_seconds, \"Timestamp overflow\");\n\n    assert(current_timestamp <= attestation_timestamp + max_age_seconds, \"Attestation expired\");\n}\n\nfn compute_policy_hash(\n    policy_min_annual_revenue: u64,\n    policy_min_ebitda: u64,\n    policy_min_tangible_net_worth: u64,\n    policy_min_business_age_days: u64,\n    policy_max_defaults_36_months: u64,\n    policy_bankruptcy_excluded: bool,\n    policy_max_debt_to_ebitda: u64,\n    policy_min_interest_coverage: u64,\n    policy_min_current_ratio: u64,\n    policy_min_ebitda_margin_bps: u64,\n    policy_max_attestation_age_days: u64,\n    tier_id: u8,\n    tier_min_revenue: u64,\n    tier_max_revenue: u64,\n    tier_min_ebitda: u64,\n    tier_max_debt_to_ebitda: u64,\n    tier_max_loan_to_ebitda: u64,\n    tier_interest_rate_bps: u64,\n    tier_origination_fee_bps: u64,\n    tier_term_days: u64,\n    tier_active: bool,\n) -> Field {\n    poseidon2::Poseidon2::hash(\n        [\n            policy_min_annual_revenue as Field,\n            policy_min_ebitda as Field,\n            policy_min_tangible_net_worth as Field,\n            policy_min_business_age_days as Field,\n            policy_max_defaults_36_months as Field,\n            policy_bankruptcy_excluded as Field,\n            policy_max_debt_to_ebitda as Field,\n            policy_min_interest_coverage as Field,\n            policy_min_current_ratio as Field,\n            policy_min_ebitda_margin_bps as Field,\n            policy_max_attestation_age_days as Field,\n            // Tier constraints\n            tier_id as Field, // Bind Tier ID to policy hash\n            tier_min_revenue as Field,\n            tier_max_revenue as Field,\n            tier_min_ebitda as Field,\n            tier_max_debt_to_ebitda as Field,\n            tier_max_loan_to_ebitda as Field,\n            tier_interest_rate_bps as Field,\n            tier_origination_fee_bps as Field,\n            tier_term_days as Field,\n            tier_active as Field,\n        ],\n        21,\n    )\n}\n\nfn validate_policy_compliance(\n    borrower_annual_revenue: u64,\n    borrower_ebitda: u64,\n    borrower_tangible_net_worth: u64,\n    borrower_business_age_days: u64,\n    borrower_defaults_last_36_months: u64,\n    borrower_has_bankruptcy: bool,\n    borrower_debt_to_ebitda: u64,\n    borrower_interest_coverage: u64,\n    borrower_current_ratio: u64,\n    borrower_ebitda_margin_bps: u64,\n    policy_min_annual_revenue: u64,\n    policy_min_ebitda: u64,\n    policy_min_tangible_net_worth: u64,\n    policy_min_business_age_days: u64,\n    policy_max_defaults_36_months: u64,\n    policy_bankruptcy_excluded: bool,\n    policy_max_debt_to_ebitda: u64,\n    policy_min_interest_coverage: u64,\n    policy_min_current_ratio: u64,\n    policy_min_ebitda_margin_bps: u64,\n    tier_min_revenue: u64,\n    tier_max_revenue: u64,\n    tier_min_ebitda: u64,\n    tier_max_debt_to_ebitda: u64,\n    tier_max_loan_to_ebitda: u64,\n    tier_interest_rate_bps: u64,\n    tier_origination_fee_bps: u64,\n    tier_term_days: u64,\n    tier_active: bool,\n    loan_principal: u64,\n    loan_apr_bps: u64,\n    loan_origination_fee_bps: u64,\n    loan_term_days: u64,\n) {\n    // 3. ELIGIBILITY\n    assert(borrower_annual_revenue >= policy_min_annual_revenue, \"Annual revenue below minimum\");\n    assert(borrower_ebitda >= policy_min_ebitda, \"EBITDA below minimum\");\n    assert(\n        borrower_tangible_net_worth >= policy_min_tangible_net_worth,\n        \"Tangible net worth below minimum\",\n    );\n    assert(\n        borrower_business_age_days >= policy_min_business_age_days,\n        \"Business age below minimum\",\n    );\n    assert(\n        borrower_defaults_last_36_months <= policy_max_defaults_36_months,\n        \"Too many defaults in last 36 months\",\n    );\n\n    if policy_bankruptcy_excluded {\n        assert(!borrower_has_bankruptcy, \"Bankruptcy excludes borrower\");\n    }\n\n    // 4. FINANCIAL RATIOS\n    assert(\n        borrower_debt_to_ebitda <= policy_max_debt_to_ebitda,\n        \"Debt-to-EBITDA ratio exceeds maximum\",\n    );\n    assert(\n        borrower_interest_coverage >= policy_min_interest_coverage,\n        \"Interest coverage ratio below minimum\",\n    );\n    assert(borrower_current_ratio >= policy_min_current_ratio, \"Current ratio below minimum\");\n    assert(\n        borrower_ebitda_margin_bps >= policy_min_ebitda_margin_bps,\n        \"EBITDA margin below minimum\",\n    );\n\n    // 5. TIER CONSTRAINTS\n    assert(tier_active, \"Loan tier is not active\");\n    assert(borrower_annual_revenue >= tier_min_revenue, \"Revenue below tier minimum\");\n    assert(borrower_annual_revenue <= tier_max_revenue, \"Revenue above tier maximum\");\n    assert(borrower_ebitda >= tier_min_ebitda, \"EBITDA below tier minimum\");\n    assert(\n        borrower_debt_to_ebitda <= tier_max_debt_to_ebitda,\n        \"Debt-to-EBITDA exceeds tier maximum\",\n    );\n\n    // Verify Policy Compliance\n    // ========================\n    // Security Note:\n    // Noir inputs typed as `u64` enforce implicit range constraints (x < 2^64).\n    // If a prover provides a value >= 2^64, the proof generation fails.\n    // Therefore, \"modular wrap-around\" attacks on inputs are impossible at the circuit level.\n    //\n    // Guard against scale overflow on valid u64 inputs:\n    // We strictly limit inputs to < 1 Quadrillion (10^15).\n    // Max result: 10^15 * 10^4 = 10^19 (fits in u64: ~1.84 * 10^19).\n    // This guarantees no integer wrap-around even with malicious inputs.\n    // The Field modulus is ~10^77, so we are nowhere near Poseidon limits.\n    // ---- Business logic sanity guards ----\n    // Prevent nonsensical proofs that are technically valid but economically meaningless\n    assert(loan_principal > 0, \"Loan principal must be non-zero\");\n    assert(borrower_ebitda > 0, \"Borrower EBITDA must be non-zero\");\n    assert(loan_apr_bps < 10000, \"APR exceeds 100%\"); // No legitimate loan > 100% APR\n    assert(loan_term_days > 0, \"Loan term must be non-zero\");\n    assert(loan_term_days <= 3650, \"Loan term exceeds 10 years\"); // 10 year max\n\n    // ---- Overflow guards ----\n    assert(loan_principal < 1_000_000_000_000_000, \"Loan principal too large\");\n    assert(borrower_ebitda < 1_000_000_000_000_000, \"EBITDA too large\");\n\n    // Loan-to-EBITDA check: loan_principal / borrower_ebitda <= tier_max_loan_to_ebitda / 1e18\n    // Cross-multiply: loan_principal * 1e18 <= borrower_ebitda * tier_max_loan_to_ebitda\n    // Direct 1e18 multiply overflows u64, so divide both sides by 1e15:\n    //   loan_principal * 1,000 <= borrower_ebitda * (tier_max / 1e15)\n    //\n    // Overflow analysis (all inputs < 1e15, tier ratio < 10e18):\n    //   Left max:  1e15 * 1,000      = 1e18  (fits u64: max ~1.84e19)\n    //   Right max: 1e15 * 10,000     = 1e19  (fits u64: max ~1.84e19)\n    assert(\n        tier_max_loan_to_ebitda < 10_000_000_000_000_000_000,\n        \"Tier loan-to-EBITDA ratio too large\",\n    ); // < 10x\n    let loan_scaled = loan_principal * 1_000;\n    let tier_ratio_descaled = tier_max_loan_to_ebitda / 1_000_000_000_000_000; // divide by 1e15\n    let max_loan = borrower_ebitda * tier_ratio_descaled;\n    assert(loan_scaled <= max_loan, \"Loan-to-EBITDA exceeds tier maximum\");\n\n    //==============================================================\n    //             6. VERIFY LOAN TERMS MATCH TIER\n    //==============================================================\n    assert(loan_apr_bps == tier_interest_rate_bps, \"APR does not match tier rate\");\n    assert(\n        loan_origination_fee_bps == tier_origination_fee_bps,\n        \"Origination fee does not match tier\",\n    );\n    assert(loan_term_days == tier_term_days, \"Term does not match tier\");\n}\n\n//==============================================================\n//                         TESTS\n//==============================================================\n\n#[test]\nfn test_policy_compliance_valid() {\n    // Borrower data\n\n    let borrower_annual_revenue: u64 = 5_000_000;\n    let borrower_ebitda: u64 = 750_000;\n    let borrower_tangible_net_worth: u64 = 1_000_000;\n    let borrower_business_age_days: u64 = 1095;\n\n    let borrower_defaults_last_36_months: u64 = 0;\n    let borrower_has_bankruptcy: bool = false;\n    let borrower_debt_to_ebitda: u64 = 25000;\n    let borrower_interest_coverage: u64 = 20000;\n    let borrower_current_ratio: u64 = 15000;\n    let borrower_ebitda_margin_bps: u64 = 1500;\n\n    // Policy constraints\n    let policy_min_annual_revenue: u64 = 1_000_000;\n    let policy_min_ebitda: u64 = 100_000;\n    let policy_min_tangible_net_worth: u64 = 250_000;\n    let policy_min_business_age_days: u64 = 730;\n    let policy_max_defaults_36_months: u64 = 0;\n    let policy_bankruptcy_excluded: bool = true;\n    let policy_max_debt_to_ebitda: u64 = 40000;\n    let policy_min_interest_coverage: u64 = 15000;\n    let policy_min_current_ratio: u64 = 12000;\n    let policy_min_ebitda_margin_bps: u64 = 1000;\n    let tier_min_revenue: u64 = 1_000_000;\n    let tier_max_revenue: u64 = 10_000_000;\n    let tier_min_ebitda: u64 = 100_000;\n    let tier_max_debt_to_ebitda: u64 = 40000;\n    let tier_max_loan_to_ebitda: u64 = 1_000_000_000_000_000_000; // 1.0x in 1e18 scaling\n    let tier_interest_rate_bps: u64 = 1200;\n    let tier_origination_fee_bps: u64 = 100;\n    let tier_term_days: u64 = 365;\n    let tier_active: bool = true;\n\n    // Bypass main and test validation logic directly\n    validate_policy_compliance(\n        borrower_annual_revenue,\n        borrower_ebitda,\n        borrower_tangible_net_worth,\n        borrower_business_age_days,\n        borrower_defaults_last_36_months,\n        borrower_has_bankruptcy,\n        borrower_debt_to_ebitda,\n        borrower_interest_coverage,\n        borrower_current_ratio,\n        borrower_ebitda_margin_bps,\n        policy_min_annual_revenue,\n        policy_min_ebitda,\n        policy_min_tangible_net_worth,\n        policy_min_business_age_days,\n        policy_max_defaults_36_months,\n        policy_bankruptcy_excluded,\n        policy_max_debt_to_ebitda,\n        policy_min_interest_coverage,\n        policy_min_current_ratio,\n        policy_min_ebitda_margin_bps,\n        tier_min_revenue,\n        tier_max_revenue,\n        tier_min_ebitda,\n        tier_max_debt_to_ebitda,\n        tier_max_loan_to_ebitda,\n        tier_interest_rate_bps,\n        tier_origination_fee_bps,\n        tier_term_days,\n        tier_active,\n        500_000, // loan_principal\n        1200, // loan_apr_bps\n        100, // loan_origination_fee_bps\n        365, // loan_term_days\n    );\n}\n\n#[test(should_fail_with = \"Annual revenue below minimum\")]\nfn test_fail_revenue_low() {\n    let borrower_annual_revenue: u64 = 500_000; // Too low (limit 1M)\n\n    // Other values valid\n    validate_policy_compliance(\n        borrower_annual_revenue,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000, // tier_max_loan_to_ebitda (1.0x in 1e18)\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n#[test(should_fail_with = \"Debt-to-EBITDA ratio exceeds maximum\")]\nfn test_fail_debt_ratio_high() {\n    let borrower_debt_to_ebitda: u64 = 45000; // 4.5x (limit 4.0x)\n\n    // Other values valid\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        borrower_debt_to_ebitda,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000, // tier_max_loan_to_ebitda (1.0x in 1e18)\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n// ============================================================\n// NEGATIVE TESTS: One per assert path in validate_policy_compliance\n// Baseline valid values used across all tests:\n//   borrower: revenue=5M, ebitda=750K, net_worth=1M, age=1095d, defaults=0, no bankruptcy\n//   ratios: debt_to_ebitda=25000(2.5x), int_coverage=20000(2.0x), current=15000(1.5x), margin=1500bps\n//   policy: min_rev=1M, min_ebitda=100K, min_nw=250K, min_age=730d, max_defaults=0, bankruptcy_excluded\n//   policy ratios: max_debt=40000(4.0x), min_coverage=15000(1.5x), min_current=12000(1.2x), min_margin=1000bps\n//   tier: rev=[1M,10M], ebitda>=100K, max_debt=40000, max_loan=1e18(1.0x), apr=1200, fee=100, term=365, active\n//   loan: principal=500K, apr=1200, fee=100, term=365\n// ============================================================\n\n#[test(should_fail_with = \"EBITDA below minimum\")]\nfn test_fail_ebitda_low() {\n    validate_policy_compliance(\n        5_000_000,\n        50_000, // EBITDA below policy minimum (100K)\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n#[test(should_fail_with = \"Tangible net worth below minimum\")]\nfn test_fail_net_worth_low() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        100_000, // Net worth below minimum (250K)\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n#[test(should_fail_with = \"Business age below minimum\")]\nfn test_fail_business_age_low() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        365, // Business age below minimum (730 days)\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n#[test(should_fail_with = \"Too many defaults in last 36 months\")]\nfn test_fail_too_many_defaults() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        1, // Defaults = 1, max allowed = 0\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n#[test(should_fail_with = \"Bankruptcy excludes borrower\")]\nfn test_fail_bankruptcy() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        true, // Has bankruptcy, policy excludes it\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n#[test(should_fail_with = \"Interest coverage ratio below minimum\")]\nfn test_fail_interest_coverage_low() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        10000, // Interest coverage 1.0x, minimum is 1.5x (15000)\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n#[test(should_fail_with = \"Current ratio below minimum\")]\nfn test_fail_current_ratio_low() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        10000, // Current ratio 1.0x, minimum is 1.2x (12000)\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n#[test(should_fail_with = \"EBITDA margin below minimum\")]\nfn test_fail_ebitda_margin_low() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        500, // Margin 5%, minimum is 10% (1000 bps)\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n#[test(should_fail_with = \"Loan tier is not active\")]\nfn test_fail_tier_inactive() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        false, // Tier is inactive\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n#[test(should_fail_with = \"Revenue below tier minimum\")]\nfn test_fail_revenue_below_tier() {\n    validate_policy_compliance(\n        500_000, // Revenue below tier minimum (1M) -- also below policy, but tier check hits first\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        100_000, // Lower policy min so policy check passes\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n#[test(should_fail_with = \"Revenue above tier maximum\")]\nfn test_fail_revenue_above_tier() {\n    validate_policy_compliance(\n        15_000_000, // Revenue above tier max (10M)\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n#[test(should_fail_with = \"EBITDA below tier minimum\")]\nfn test_fail_ebitda_below_tier() {\n    validate_policy_compliance(\n        5_000_000,\n        50_000, // EBITDA below tier minimum (100K) -- also below policy, but policy trips first\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        10_000, // Lower policy min so policy check passes\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n#[test(should_fail_with = \"Debt-to-EBITDA exceeds tier maximum\")]\nfn test_fail_debt_exceeds_tier() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        35000, // 3.5x -- passes policy max (4.0x) but exceeds tier max (3.0x)\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        30000, // Tier max 3.0x (less than policy max)\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n#[test(should_fail_with = \"Loan principal too large\")]\nfn test_fail_principal_too_large() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        1_000_000_000_000_000, // Exactly at limit (should fail, guard is strict <)\n        1200,\n        100,\n        365,\n    );\n}\n\n#[test(should_fail_with = \"EBITDA too large\")]\nfn test_fail_ebitda_too_large() {\n    validate_policy_compliance(\n        5_000_000,\n        1_000_000_000_000_000, // EBITDA at overflow guard limit\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n#[test(should_fail_with = \"Tier loan-to-EBITDA ratio too large\")]\nfn test_fail_tier_ratio_too_large() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        10_000_000_000_000_000_000, // 10x -- at the guard limit (strict <)\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n#[test(should_fail_with = \"Loan-to-EBITDA exceeds tier maximum\")]\nfn test_fail_loan_to_ebitda_exceeded() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        500_000_000_000_000_000, // 0.5x -- loan 500K / ebitda 750K = 0.67x exceeds 0.5x\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n#[test(should_fail_with = \"APR does not match tier rate\")]\nfn test_fail_apr_mismatch() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1500, // APR 15% but tier specifies 12%\n        100,\n        365,\n    );\n}\n\n#[test(should_fail_with = \"Origination fee does not match tier\")]\nfn test_fail_origination_fee_mismatch() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        200, // Fee 2% but tier specifies 1%\n        365,\n    );\n}\n\n#[test(should_fail_with = \"Term does not match tier\")]\nfn test_fail_term_mismatch() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        180, // 180 days but tier specifies 365\n    );\n}\n\n// ============================================================\n// NEGATIVE TESTS: Business logic sanity guards\n// ============================================================\n\n#[test(should_fail_with = \"Loan principal must be non-zero\")]\nfn test_fail_zero_principal() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        0, // Zero principal\n        1200,\n        100,\n        365,\n    );\n}\n\n#[test(should_fail_with = \"Borrower EBITDA must be non-zero\")]\nfn test_fail_zero_ebitda() {\n    validate_policy_compliance(\n        5_000_000,\n        0, // Zero EBITDA\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        0, // policy min also 0 so policy check passes\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        0, // tier min also 0\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n#[test(should_fail_with = \"APR exceeds 100%\")]\nfn test_fail_apr_too_high() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        15000, // tier rate 150% -- matches loan APR so tier check passes\n        100,\n        365,\n        true,\n        500_000,\n        15000, // 150% APR\n        100,\n        365,\n    );\n}\n\n#[test(should_fail_with = \"Loan term must be non-zero\")]\nfn test_fail_zero_term() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        0, // tier term 0 -- matches loan so tier check passes\n        true,\n        500_000,\n        1200,\n        100,\n        0, // Zero term\n    );\n}\n\n#[test(should_fail_with = \"Loan term exceeds 10 years\")]\nfn test_fail_term_too_long() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        3651, // tier term matches loan\n        true,\n        500_000,\n        1200,\n        100,\n        3651, // 10 years + 1 day\n    );\n}\n\n// ============================================================\n// BOUNDARY VALUE TESTS: Exact edge cases (pass at limit, fail at limit +/- 1)\n// ============================================================\n\n// --- Revenue at exact policy minimum (should PASS) ---\n#[test]\nfn test_boundary_revenue_at_policy_min() {\n    validate_policy_compliance(\n        1_000_000, // Exactly at policy min\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n// --- Revenue 1 below policy minimum (should FAIL) ---\n#[test(should_fail_with = \"Annual revenue below minimum\")]\nfn test_boundary_revenue_one_below_policy_min() {\n    validate_policy_compliance(\n        999_999, // 1 below policy min of 1M\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n// --- Revenue at exact tier maximum (should PASS) ---\n#[test]\nfn test_boundary_revenue_at_tier_max() {\n    validate_policy_compliance(\n        10_000_000, // Exactly at tier max\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n// --- Revenue 1 above tier maximum (should FAIL) ---\n#[test(should_fail_with = \"Revenue above tier maximum\")]\nfn test_boundary_revenue_one_above_tier_max() {\n    validate_policy_compliance(\n        10_000_001, // 1 above tier max of 10M\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n// --- Debt ratio at exact policy max (should PASS) ---\n#[test]\nfn test_boundary_debt_ratio_at_max() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        40000, // Exactly at policy max (4.0x)\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n// --- Debt ratio 1 above policy max (should FAIL) ---\n#[test(should_fail_with = \"Debt-to-EBITDA ratio exceeds maximum\")]\nfn test_boundary_debt_ratio_one_above_max() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        40001, // 1 above policy max (4.0001x)\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n// --- APR at 99.99% (should PASS) ---\n#[test]\nfn test_boundary_apr_at_max() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        9999, // tier rate = 99.99%\n        100,\n        365,\n        true,\n        500_000,\n        9999, // APR at 99.99% -- just under 100% limit\n        100,\n        365,\n    );\n}\n\n// --- APR at exactly 100% (should FAIL) ---\n#[test(should_fail_with = \"APR exceeds 100%\")]\nfn test_boundary_apr_at_100_percent() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        10000, // tier rate = 100%\n        100,\n        365,\n        true,\n        500_000,\n        10000, // APR at exactly 100% (10000 bps)\n        100,\n        365,\n    );\n}\n\n// --- Term at exactly 3650 days / 10 years (should PASS) ---\n#[test]\nfn test_boundary_term_at_max() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        3650, // tier term matches\n        true,\n        500_000,\n        1200,\n        100,\n        3650, // Exactly 10 years\n    );\n}\n\n// --- Term at 3651 days (should FAIL) ---\n// Already covered by test_fail_term_too_long\n\n// --- Principal at 1e15 - 1 (should PASS overflow guard) ---\n#[test]\nfn test_boundary_principal_just_under_limit() {\n    validate_policy_compliance(\n        5_000_000,\n        999_999_999_999_999, // Large EBITDA so ratio check passes\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        2_000_000_000_000_000_000, // 2.0x\n        1200,\n        100,\n        365,\n        true,\n        999_999_999_999_999, // 1e15 - 1 (just under overflow guard)\n        1200,\n        100,\n        365,\n    );\n}\n\n// --- Principal at 1e15 (should FAIL) ---\n// Already covered by test_fail_principal_too_large\n\n// --- EBITDA at 1e15 - 1 (should PASS overflow guard) ---\n#[test]\nfn test_boundary_ebitda_just_under_limit() {\n    validate_policy_compliance(\n        5_000_000,\n        999_999_999_999_999, // 1e15 - 1\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n// --- Tier ratio at 10e18 - 1 (should PASS guard) ---\n#[test]\nfn test_boundary_tier_ratio_just_under_limit() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        9_999_999_999_999_999_999, // 10e18 - 1 (just under 10x)\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n// --- Interest coverage at exact minimum (should PASS) ---\n#[test]\nfn test_boundary_interest_coverage_at_min() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        15000, // Exactly at policy min (1.5x)\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n// --- Interest coverage 1 below minimum (should FAIL) ---\n#[test(should_fail_with = \"Interest coverage ratio below minimum\")]\nfn test_boundary_interest_coverage_one_below_min() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        1095,\n        0,\n        false,\n        25000,\n        14999, // 1 below policy min\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n// --- Business age at exact minimum (should PASS) ---\n#[test]\nfn test_boundary_business_age_at_min() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        730, // Exactly at policy min\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n// --- Business age 1 below minimum (should FAIL) ---\n#[test(should_fail_with = \"Business age below minimum\")]\nfn test_boundary_business_age_one_below_min() {\n    validate_policy_compliance(\n        5_000_000,\n        750_000,\n        1_000_000,\n        729, // 1 below policy min of 730\n        0,\n        false,\n        25000,\n        20000,\n        15000,\n        1500,\n        1_000_000,\n        100_000,\n        250_000,\n        730,\n        0,\n        true,\n        40000,\n        15000,\n        12000,\n        1000,\n        1_000_000,\n        10_000_000,\n        100_000,\n        40000,\n        1_000_000_000_000_000_000,\n        1200,\n        100,\n        365,\n        true,\n        500_000,\n        1200,\n        100,\n        365,\n    );\n}\n\n#[test]\nfn test_loan_hash_computation() {\n    let hash = compute_loan_hash(\n        123, // commitment\n        456, // pk_x\n        789, // pk_y\n        1, // tier_id\n        100000, // principal\n        500, // apr\n        100, // fee\n        365, // term\n        111, // industry\n        1625097600, // timestamp\n        999, // loanId\n    );\n    // Since poseidon is deterministic, we can just assert it runs and returns a field.\n    assert(hash != 0);\n}\n\n// ----------------------------------------------------\n// New Unit Tests for Logic Helper Functions\n// ----------------------------------------------------\n\n#[test]\nfn test_verify_attestation_age_valid() {\n    let now: u64 = 100000;\n    let attested: u64 = 95000;\n    let max_age_days: u64 = 1; // 86400 seconds\n    // 95000 + 86400 = 181400 > 100000. Valid.\n    verify_attestation_age(now, attested, max_age_days);\n}\n\n#[test(should_fail_with = \"Attestation expired\")]\nfn test_verify_attestation_age_expired() {\n    let now: u64 = 200000;\n    let attested: u64 = 100000;\n    let max_age_days: u64 = 1; // 86400 seconds\n    // 100000 + 86400 = 186400 < 200000. Expired.\n    verify_attestation_age(now, attested, max_age_days);\n}\n\n#[test(should_fail_with = \"Attestation time in future\")]\nfn test_verify_attestation_future() {\n    let now: u64 = 100000;\n    let attested: u64 = 100001; // Future\n    let max_age_days: u64 = 1;\n    verify_attestation_age(now, attested, max_age_days);\n}\n\n#[test]\nfn test_verify_borrower_commitment_valid() {\n    let secret = 123;\n    let rev = 100;\n    let ebitda = 50;\n    let nw = 200;\n    let age = 365;\n\n    let expected_commitment = poseidon2::Poseidon2::hash(\n        [secret, rev as Field, ebitda as Field, nw as Field, age as Field],\n        5,\n    );\n\n    verify_borrower_commitment(expected_commitment, secret, rev, ebitda, nw, age);\n}\n\n#[test(should_fail_with = \"Borrower commitment mismatch\")]\nfn test_verify_borrower_commitment_invalid() {\n    let secret = 123;\n    let rev = 100;\n    let ebitda = 50;\n    let nw = 200;\n    let age = 365;\n\n    let fake_commitment = 999999; // Random wrong commitment\n\n    verify_borrower_commitment(fake_commitment, secret, rev, ebitda, nw, age);\n}\n\n#[test]\nfn test_compute_policy_hash_deterministic() {\n    // Just verify it computes something non-zero given inputs\n    let h1 = compute_policy_hash(\n        1,\n        1,\n        1,\n        1,\n        1,\n        true,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        true,\n    );\n    let h2 = compute_policy_hash(\n        1,\n        1,\n        1,\n        1,\n        1,\n        true,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        1,\n        true,\n    );\n    assert(h1 == h2);\n    assert(h1 != 0);\n}\n","path":"/Users/admin/Desktop/credit_rail/circuits/src/main.nr"},"60":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        self.state[0] += self.cache[0];\n        self.state[1] += self.cache[1];\n        self.state[2] += self.cache[2];\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut state = [0; 4];\n        state[RATE] = iv;\n\n        if std::runtime::is_unconstrained() {\n            for i in 0..(in_len / RATE) {\n                state[0] += input[i * RATE];\n                state[1] += input[i * RATE + 1];\n                state[2] += input[i * RATE + 2];\n                state = crate::poseidon2_permutation(state, 4);\n            }\n\n            // handle remaining elements after last full RATE-sized chunk\n            let num_extra_fields = in_len % RATE;\n            if num_extra_fields != 0 {\n                let remainder_start = in_len - num_extra_fields;\n                state[0] += input[remainder_start];\n                if num_extra_fields > 1 {\n                    state[1] += input[remainder_start + 1]\n                }\n            }\n        } else {\n            let mut states: [[Field; 4]; N / RATE + 1] = [[0; 4]; N / RATE + 1];\n            states[0] = state;\n\n            // process all full RATE-sized chunks, storing state after each permutation\n            for chunk_idx in 0..(N / RATE) {\n                for i in 0..RATE {\n                    state[i] += input[chunk_idx * RATE + i];\n                }\n                state = crate::poseidon2_permutation(state, 4);\n                states[chunk_idx + 1] = state;\n            }\n\n            // get state at the last full block before in_len\n            let first_partially_filled_chunk = in_len / RATE;\n            state = states[first_partially_filled_chunk];\n\n            // handle remaining elements after last full RATE-sized chunk\n            let remainder_start = (in_len / RATE) * RATE;\n            for j in 0..RATE {\n                let idx = remainder_start + j;\n                if idx < in_len {\n                    state[j] += input[idx];\n                }\n            }\n        }\n\n        // always run final permutation unless we just completed a full chunk\n        // still need to permute once if in_len is 0\n        if (in_len == 0) | (in_len % RATE != 0) {\n            state = crate::poseidon2_permutation(state, 4)\n        };\n\n        state[0]\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/admin/nargo/github.com/noir-lang/poseidon/v0.2.3/src/poseidon2.nr"}},"expression_width":{"Bounded":{"width":4}}}